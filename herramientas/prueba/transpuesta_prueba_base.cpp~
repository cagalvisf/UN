#include <iostream>
#include <cstdio>
#include <cstdlib>
#include "papi.h"

int code_to_be_measured(const double * M, double * MT, int N);
int main(int argc, char **argv)
{
  int N= 0;
 
  // PAPI vars
  float real_time, proc_time,mflops;
  long long flpops;
  float ireal_time, iproc_time, imflops;
  long long iflpops;
  int retval;
  // PERFOMANCE MEASURE
  // start PAPI counters
  if((retval=PAPI_flops(&ireal_time,&iproc_time,&iflpops,&imflops)) < PAPI_OK)
    {
      printf("Could not initialise PAPI_flops \n");
      printf("Your platform may not support floating point operation event.\n");
      printf("retval: %d\n", retval);
      exit(1);
    }

  for (int ii=1;ii<14;ii++)
    {
      N=std::pow(2,ii);
      double *A = new double [N*N], *AT = new double [N*N];
      // initialize matrices
      for (int ii =1; ii < N; ++ii) {
	for (int jj =0; jj < N; ++jj) {
	  A[ii*N + jj] = ii + jj + 1;
	  AT[ii*N + jj] = 0.0;
	}
      }
       
      code_to_be_measured(A, AT,N);
      if((retval=PAPI_flops( &real_time, &proc_time, &flpops, &mflops))<PAPI_OK)
	{
	  printf("retval: %d\n", retval);
	  exit(1);
	}
      std::cout<<N<<" "<<proc_tiem<<std::endl;
	    
      delete [] A;
      delete [] AT;
    }
  return 0;
}
int code_to_be_measured(const double * M, double * MT, int,int N )
{
  // simple matrix transpose
  for (int ii = 0; ii < N; ++ii) {
    for (int jj = 0; jj < N; ++jj) {
      MT[ii*N +jj] = M[jj*N + ii];
    }
  }
  return 0;
}
